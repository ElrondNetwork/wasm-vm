diff a/arwen/contexts/storage_test.go b/arwen/contexts/storage_test.go	(rejected hunks)
@@ -28,27 +28,27 @@ func TestNewStorageContext(t *testing.T) {
 		host := &contextmock.VMHostMock{}
 		mockBlockchain := worldmock.NewMockWorld()
 
-		storageContextInstance, err := NewStorageContext(host, mockBlockchain, make([]byte, 0))
+		storageCtx, err := NewStorageContext(host, mockBlockchain, make([]byte, 0))
 		require.Equal(t, arwen.ErrEmptyProtectedKeyPrefix, err)
-		require.True(t, check.IfNil(storageContextInstance))
+		require.True(t, check.IfNil(storageCtx))
 	})
 	t.Run("nil VM host should error", func(t *testing.T) {
 		t.Parallel()
 
 		mockBlockchain := worldmock.NewMockWorld()
 
-		storageContextInstance, err := NewStorageContext(nil, mockBlockchain, elrondReservedTestPrefix)
+		storageCtx, err := NewStorageContext(nil, mockBlockchain, elrondReservedTestPrefix)
 		require.Equal(t, arwen.ErrNilVMHost, err)
-		require.True(t, check.IfNil(storageContextInstance))
+		require.True(t, check.IfNil(storageCtx))
 	})
 	t.Run("nil blockchain hook should error", func(t *testing.T) {
 		t.Parallel()
 
 		host := &contextmock.VMHostMock{}
 
-		storageContextInstance, err := NewStorageContext(host, nil, elrondReservedTestPrefix)
+		storageCtx, err := NewStorageContext(host, nil, elrondReservedTestPrefix)
 		require.Equal(t, arwen.ErrNilBlockChainHook, err)
-		require.True(t, check.IfNil(storageContextInstance))
+		require.True(t, check.IfNil(storageCtx))
 	})
 	t.Run("should work", func(t *testing.T) {
 		t.Parallel()
@@ -61,9 +61,9 @@ func TestNewStorageContext(t *testing.T) {
 		}
 		mockBlockchain := worldmock.NewMockWorld()
 
-		storageContextInstance, err := NewStorageContext(host, mockBlockchain, elrondReservedTestPrefix)
+		storageCtx, err := NewStorageContext(host, mockBlockchain, elrondReservedTestPrefix)
 		require.Nil(t, err)
-		require.False(t, check.IfNil(storageContextInstance))
+		require.False(t, check.IfNil(storageCtx))
 	})
 }
 
@@ -113,35 +113,35 @@ func TestStorageContext_SetAddress(t *testing.T) {
 	}
 	bcHook := &contextmock.BlockchainHookStub{}
 
-	storageContextInstance, _ := NewStorageContext(host, bcHook, elrondReservedTestPrefix)
+	storageCtx, _ := NewStorageContext(host, bcHook, elrondReservedTestPrefix)
 
 	keyA := []byte("keyA")
 	valueA := []byte("valueA")
 
-	storageContextInstance.SetAddress(addressA)
-	storageStatus, err := storageContextInstance.SetStorage(keyA, valueA)
+	storageCtx.SetAddress(addressA)
+	storageStatus, err := storageCtx.SetStorage(keyA, valueA)
 	require.Nil(t, err)
 	require.Equal(t, arwen.StorageAdded, storageStatus)
 	require.Equal(t, uint64(len(valueA)), accountA.BytesAddedToStorage)
 	require.Equal(t, uint64(0), accountA.BytesDeletedFromStorage)
-	foundValueA, _, _ := storageContextInstance.GetStorage(keyA)
+	foundValueA, _, _ := storageCtx.GetStorage(keyA)
 	require.Equal(t, valueA, foundValueA)
-	require.Len(t, storageContextInstance.GetStorageUpdates(addressA), 1)
-	require.Len(t, storageContextInstance.GetStorageUpdates(addressB), 0)
+	require.Len(t, storageCtx.GetStorageUpdates(addressA), 1)
+	require.Len(t, storageCtx.GetStorageUpdates(addressB), 0)
 
 	keyB := []byte("keyB")
 	valueB := []byte("valueB")
-	storageContextInstance.SetAddress(addressB)
-	storageStatus, err = storageContextInstance.SetStorage(keyB, valueB)
+	storageCtx.SetAddress(addressB)
+	storageStatus, err = storageCtx.SetStorage(keyB, valueB)
 	require.Equal(t, uint64(len(valueB)), accountB.BytesAddedToStorage)
 	require.Equal(t, uint64(0), accountB.BytesDeletedFromStorage)
 	require.Nil(t, err)
 	require.Equal(t, arwen.StorageAdded, storageStatus)
-	foundValueB, _, _ := storageContextInstance.GetStorage(keyB)
+	foundValueB, _, _ := storageCtx.GetStorage(keyB)
 	require.Equal(t, valueB, foundValueB)
-	require.Len(t, storageContextInstance.GetStorageUpdates(addressA), 1)
-	require.Len(t, storageContextInstance.GetStorageUpdates(addressB), 1)
-	foundValueA, _, _ = storageContextInstance.GetStorage(keyA)
+	require.Len(t, storageCtx.GetStorageUpdates(addressA), 1)
+	require.Len(t, storageCtx.GetStorageUpdates(addressB), 1)
+	foundValueA, _, _ = storageCtx.GetStorage(keyA)
 	require.Equal(t, []byte(nil), foundValueA)
 }
 
@@ -168,9 +168,9 @@ func TestStorageContext_GetStorageUpdates(t *testing.T) {
 	}
 
 	mockBlockchainHook := worldmock.NewMockWorld()
-	storageContextInstance, _ := NewStorageContext(host, mockBlockchainHook, elrondReservedTestPrefix)
+	storageCtx, _ := NewStorageContext(host, mockBlockchainHook, elrondReservedTestPrefix)
 
-	storageUpdates := storageContextInstance.GetStorageUpdates([]byte("account"))
+	storageUpdates := storageCtx.GetStorageUpdates([]byte("account"))
 	require.Equal(t, 1, len(storageUpdates))
 	require.Equal(t, []byte("update"), storageUpdates["update"].Offset)
 	require.Equal(t, []byte("some data"), storageUpdates["update"].Data)
@@ -201,8 +201,8 @@ func TestStorageContext_SetStorage(t *testing.T) {
 		EnableEpochsHandlerField: enableEpochsHandler,
 	}
 	bcHook := &contextmock.BlockchainHookStub{}
-	storageContextInstance, _ := NewStorageContext(host, bcHook, elrondReservedTestPrefix)
-	storageContextInstance.SetAddress(address)
+	storageCtx, _ := NewStorageContext(host, bcHook, elrondReservedTestPrefix)
+	storageCtx.SetAddress(address)
 
 	val1 := []byte("value")
 	val2 := []byte("newValue")
@@ -212,101 +212,101 @@ func TestStorageContext_SetStorage(t *testing.T) {
 	value := val1
 	addedBytes := len(value)
 
-	storageStatus, err := storageContextInstance.SetStorage(key, value)
+	storageStatus, err := storageCtx.SetStorage(key, value)
 	require.Nil(t, err)
 	require.Equal(t, arwen.StorageAdded, storageStatus)
 	require.Equal(t, uint64(addedBytes), account.BytesAddedToStorage)
 	require.Equal(t, uint64(0), account.BytesDeletedFromStorage)
-	foundValue, _, _ := storageContextInstance.GetStorage(key)
+	foundValue, _, _ := storageCtx.GetStorage(key)
 	require.Equal(t, value, foundValue)
-	require.Len(t, storageContextInstance.GetStorageUpdates(address), 1)
+	require.Len(t, storageCtx.GetStorageUpdates(address), 1)
 
 	value = val2
 	addedBytes += len(value) - len(val1)
 
-	storageStatus, err = storageContextInstance.SetStorage(key, value)
+	storageStatus, err = storageCtx.SetStorage(key, value)
 	require.Nil(t, err)
 	require.Equal(t, arwen.StorageModified, storageStatus)
 	require.Equal(t, uint64(addedBytes), account.BytesAddedToStorage)
 	require.Equal(t, uint64(0), account.BytesDeletedFromStorage)
-	foundValue, _, _ = storageContextInstance.GetStorage(key)
+	foundValue, _, _ = storageCtx.GetStorage(key)
 	require.Equal(t, value, foundValue)
-	require.Len(t, storageContextInstance.GetStorageUpdates(address), 1)
+	require.Len(t, storageCtx.GetStorageUpdates(address), 1)
 
 	value = val2
 
-	storageStatus, err = storageContextInstance.SetStorage(key, value)
+	storageStatus, err = storageCtx.SetStorage(key, value)
 	require.Nil(t, err)
 	require.Equal(t, arwen.StorageUnchanged, storageStatus)
 	require.Equal(t, uint64(addedBytes), account.BytesAddedToStorage)
 	require.Equal(t, uint64(0), account.BytesDeletedFromStorage)
-	foundValue, _, _ = storageContextInstance.GetStorage(key)
+	foundValue, _, _ = storageCtx.GetStorage(key)
 	require.Equal(t, value, foundValue)
-	require.Len(t, storageContextInstance.GetStorageUpdates(address), 1)
+	require.Len(t, storageCtx.GetStorageUpdates(address), 1)
 
 	value = val1
 	deletedBytes := len(val2) - len(val1)
 
-	storageStatus, err = storageContextInstance.SetStorage(key, value)
+	storageStatus, err = storageCtx.SetStorage(key, value)
 	require.Nil(t, err)
 	require.Equal(t, arwen.StorageModified, storageStatus)
 	require.Equal(t, uint64(addedBytes), account.BytesAddedToStorage)
 	require.Equal(t, uint64(deletedBytes), account.BytesDeletedFromStorage)
-	foundValue, _, _ = storageContextInstance.GetStorage(key)
+	foundValue, _, _ = storageCtx.GetStorage(key)
 	require.Equal(t, value, foundValue)
-	require.Len(t, storageContextInstance.GetStorageUpdates(address), 1)
+	require.Len(t, storageCtx.GetStorageUpdates(address), 1)
 
 	value = val3
 	deletedBytes += len(val1) - len(val3)
 
-	storageStatus, err = storageContextInstance.SetStorage(key, value)
+	storageStatus, err = storageCtx.SetStorage(key, value)
 	require.Nil(t, err)
 	require.Equal(t, arwen.StorageModified, storageStatus)
 	require.Equal(t, uint64(addedBytes), account.BytesAddedToStorage)
 	require.Equal(t, uint64(deletedBytes), account.BytesDeletedFromStorage)
-	foundValue, _, _ = storageContextInstance.GetStorage(key)
+	foundValue, _, _ = storageCtx.GetStorage(key)
 	require.Equal(t, value, foundValue)
-	require.Len(t, storageContextInstance.GetStorageUpdates(address), 1)
+	require.Len(t, storageCtx.GetStorageUpdates(address), 1)
 
 	value = nil
 	deletedBytes += len(val3)
 
-	storageStatus, err = storageContextInstance.SetStorage(key, value)
+	storageStatus, err = storageCtx.SetStorage(key, value)
 	require.Nil(t, err)
 	require.Equal(t, arwen.StorageDeleted, storageStatus)
 	require.Equal(t, uint64(addedBytes), account.BytesAddedToStorage)
 	require.Equal(t, uint64(deletedBytes), account.BytesDeletedFromStorage)
-	foundValue, _, _ = storageContextInstance.GetStorage(key)
+	foundValue, _, _ = storageCtx.GetStorage(key)
 	require.Equal(t, []byte{}, foundValue)
-	require.Len(t, storageContextInstance.GetStorageUpdates(address), 1)
+	require.Len(t, storageCtx.GetStorageUpdates(address), 1)
 
 	mockRuntime.SetReadOnly(true)
 	value = val2
-	storageStatus, err = storageContextInstance.SetStorage(key, value)
+	storageStatus, err = storageCtx.SetStorage(key, value)
 	require.Equal(t, err, arwen.ErrCannotWriteOnReadOnly)
 	require.Equal(t, arwen.StorageUnchanged, storageStatus)
-	foundValue, _, _ = storageContextInstance.GetStorage(key)
+	foundValue, _, _ = storageCtx.GetStorage(key)
 	require.Equal(t, []byte{}, foundValue)
-	require.Len(t, storageContextInstance.GetStorageUpdates(address), 1)
+	require.Len(t, storageCtx.GetStorageUpdates(address), 1)
 
 	mockRuntime.SetReadOnly(false)
 	key = []byte("other_key")
 	value = []byte("other_value")
-	storageStatus, err = storageContextInstance.SetStorage(key, value)
+	storageStatus, err = storageCtx.SetStorage(key, value)
 	require.Nil(t, err)
 	require.Equal(t, arwen.StorageAdded, storageStatus)
-	foundValue, _, _ = storageContextInstance.GetStorage(key)
+	foundValue, _, _ = storageCtx.GetStorage(key)
 	require.Equal(t, value, foundValue)
-	require.Len(t, storageContextInstance.GetStorageUpdates(address), 2)
+	require.Len(t, storageCtx.GetStorageUpdates(address), 2)
 
 	key = []byte("RESERVEDkey")
 	value = []byte("doesn't matter")
-	_, err = storageContextInstance.SetStorage(key, value)
+	_, err = storageCtx.SetStorage(key, value)
 	require.Equal(t, arwen.ErrStoreElrondReservedKey, err)
 
 	key = []byte("RESERVED")
 	value = []byte("doesn't matter")
-	_, err = storageContextInstance.SetStorage(key, value)
+	_, err = storageCtx.SetStorage(key, value)
 	require.Equal(t, arwen.ErrStoreElrondReservedKey, err)
 }
 
@@ -342,8 +342,8 @@ func TestStorageContext_SetStorage_GasUsage(t *testing.T) {
 	}
 	bcHook := &contextmock.BlockchainHookStub{}
 
-	storageContextInstance, _ := NewStorageContext(host, bcHook, elrondReservedTestPrefix)
-	storageContextInstance.SetAddress(address)
+	storageCtx, _ := NewStorageContext(host, bcHook, elrondReservedTestPrefix)
+	storageCtx.SetAddress(address)
 
 	gasProvided := 100
 	mockMetering.GasLeftMock = uint64(gasProvided)
@@ -351,9 +351,9 @@ func TestStorageContext_SetStorage_GasUsage(t *testing.T) {
 
 	// Store new value
 	value := []byte("value")
-	storageStatus, err := storageContextInstance.SetStorage(key, value)
+	storageStatus, err := storageCtx.SetStorage(key, value)
 	gasLeft := gasProvided - storeCost*len(value)
-	storedValue, _, _ := storageContextInstance.GetStorage(key)
+	storedValue, _, _ := storageCtx.GetStorage(key)
 	require.Nil(t, err)
 	require.Equal(t, arwen.StorageAdded, storageStatus)
 	require.Equal(t, gasLeft, int(mockMetering.GasLeft()))
@@ -362,8 +362,8 @@ func TestStorageContext_SetStorage_GasUsage(t *testing.T) {
 	// Update with longer value
 	value2 := []byte("value2")
 	mockMetering.GasLeftMock = uint64(gasProvided)
-	storageStatus, err = storageContextInstance.SetStorage(key, value2)
-	storedValue, _, _ = storageContextInstance.GetStorage(key)
+	storageStatus, err = storageCtx.SetStorage(key, value2)
+	storedValue, _, _ = storageCtx.GetStorage(key)
 	gasLeft = gasProvided - persistCost*len(value) - storeCost*(len(value2)-len(value))
 	require.Nil(t, err)
 	require.Equal(t, arwen.StorageModified, storageStatus)
@@ -372,10 +372,10 @@ func TestStorageContext_SetStorage_GasUsage(t *testing.T) {
 
 	// Revert to initial value
 	mockMetering.GasLeftMock = uint64(gasProvided)
-	storageStatus, err = storageContextInstance.SetStorage(key, value)
+	storageStatus, err = storageCtx.SetStorage(key, value)
 	gasLeft = gasProvided - persistCost*len(value)
 	gasFreed := releaseCost * (len(value2) - len(value))
-	storedValue, _, _ = storageContextInstance.GetStorage(key)
+	storedValue, _, _ = storageCtx.GetStorage(key)
 	require.Nil(t, err)
 	require.Equal(t, arwen.StorageModified, storageStatus)
 	require.Equal(t, gasLeft, int(mockMetering.GasLeft()))
@@ -407,37 +407,41 @@ func TestStorageContext_StorageProtection(t *testing.T) {
 	}
 	bcHook := &contextmock.BlockchainHookStub{}
 
-	storageContextInstance, _ := NewStorageContext(host, bcHook, elrondReservedTestPrefix)
-	storageContextInstance.SetAddress(address)
+	storageCtx, _ := NewStorageContext(host, bcHook, elrondReservedTestPrefix)
+	storageCtx.SetAddress(address)
 
 	key := []byte(arwen.ProtectedStoragePrefix + "something")
 	value := []byte("data")
 
-	storageStatus, err := storageContextInstance.SetStorage(key, value)
+	storageStatus, err := storageCtx.SetStorage(key, value)
 	require.Equal(t, arwen.StorageUnchanged, storageStatus)
 	require.True(t, errors.Is(err, arwen.ErrCannotWriteProtectedKey))
-	require.Len(t, storageContextInstance.GetStorageUpdates(address), 0)
+	require.Len(t, storageCtx.GetStorageUpdates(address), 0)
 
-	storageContextInstance.disableStorageProtection()
-	storageStatus, err = storageContextInstance.SetStorage(key, value)
+	storageCtx.disableStorageProtection()
+	storageStatus, err = storageCtx.SetStorage(key, value)
 	require.Nil(t, err)
 	require.Equal(t, arwen.StorageAdded, storageStatus)
-	require.Len(t, storageContextInstance.GetStorageUpdates(address), 1)
+	require.Len(t, storageCtx.GetStorageUpdates(address), 1)
 
-	storageContextInstance.enableStorageProtection()
-	storageStatus, err = storageContextInstance.SetStorage(key, value)
+	storageCtx.enableStorageProtection()
+	storageStatus, err = storageCtx.SetStorage(key, value)
 	require.Equal(t, arwen.StorageUnchanged, storageStatus)
 	require.True(t, errors.Is(err, arwen.ErrCannotWriteProtectedKey))
-	require.Len(t, storageContextInstance.GetStorageUpdates(address), 1)
+	require.Len(t, storageCtx.GetStorageUpdates(address), 1)
 }
 
 func TestStorageContext_GetStorageFromAddress(t *testing.T) {
 	t.Parallel()
 
+	scAddress := []byte("account")
+	enableEpochsHandler := &mock.EnableEpochsHandlerStub{
+		IsStorageAPICostOptimizationFlagEnabledField: true,
+	}
+
 	t.Run("blockchain hook errors", func(t *testing.T) {
 		t.Parallel()
 
-		scAddress := []byte("account")
 		mockOutput := &contextmock.OutputContextMock{}
 		account := mockOutput.NewVMOutputAccount(scAddress)
 		mockOutput.OutputAccountMock = account
@@ -448,10 +452,6 @@ func TestStorageContext_GetStorageFromAddress(t *testing.T) {
 		mockMetering.SetGasSchedule(config.MakeGasMapForTests())
 		mockMetering.BlockGasLimitMock = uint64(15000)
 
-		enableEpochsHandler := &mock.EnableEpochsHandlerStub{
-			IsStorageAPICostOptimizationFlagEnabledField: true,
-		}
-
 		host := &contextmock.VMHostMock{
 			OutputContext:            mockOutput,
 			MeteringContext:          mockMetering,
@@ -478,26 +478,25 @@ func TestStorageContext_GetStorageFromAddress(t *testing.T) {
 			},
 		}
 
-		storageContextInstance, _ := NewStorageContext(host, bcHook, elrondReservedTestPrefix)
-		storageContextInstance.SetAddress(scAddress)
+		storageCtx, _ := NewStorageContext(host, bcHook, elrondReservedTestPrefix)
+		storageCtx.SetAddress(scAddress)
 
 		key := []byte("key")
-		data, _, err := storageContextInstance.GetStorageFromAddress(scAddress, key)
+		data, _, err := storageCtx.GetStorageFromAddress(scAddress, key)
 		require.Nil(t, data)
 		assert.Equal(t, errTooManyRequests, err)
 
-		data, _, _ = storageContextInstance.GetStorageFromAddress(readable, key)
+		data, _, _ = storageCtx.GetStorageFromAddress(readable, key)
 		require.Nil(t, data)
 		assert.Equal(t, errTooManyRequests, err)
 
-		data, _, _ = storageContextInstance.GetStorageFromAddress(nonreadable, key)
+		data, _, _ = storageCtx.GetStorageFromAddress(nonreadable, key)
 		require.Nil(t, data)
 		assert.Equal(t, errTooManyRequests, err)
 	})
 	t.Run("should work when blockchain hook does not error", func(t *testing.T) {
 		t.Parallel()
 
-		scAddress := []byte("account")
 		mockOutput := &contextmock.OutputContextMock{}
 		account := mockOutput.NewVMOutputAccount(scAddress)
 		mockOutput.OutputAccountMock = account
@@ -508,10 +507,6 @@ func TestStorageContext_GetStorageFromAddress(t *testing.T) {
 		mockMetering.SetGasSchedule(config.MakeGasMapForTests())
 		mockMetering.BlockGasLimitMock = uint64(15000)
 
-		enableEpochsHandler := &mock.EnableEpochsHandlerStub{
-			IsStorageAPICostOptimizationFlagEnabledField: true,
-		}
-
 		host := &contextmock.VMHostMock{
 			OutputContext:            mockOutput,
 			MeteringContext:          mockMetering,
@@ -538,17 +533,17 @@ func TestStorageContext_GetStorageFromAddress(t *testing.T) {
 			},
 		}
 
-		storageContextInstance, _ := NewStorageContext(host, bcHook, elrondReservedTestPrefix)
-		storageContextInstance.SetAddress(scAddress)
+		storageCtx, _ := NewStorageContext(host, bcHook, elrondReservedTestPrefix)
+		storageCtx.SetAddress(scAddress)
 
 		key := []byte("key")
-		data, _, _ := storageContextInstance.GetStorageFromAddress(scAddress, key)
+		data, _, _ := storageCtx.GetStorageFromAddress(scAddress, key)
 		require.Equal(t, data, internalData)
 
-		data, _, _ = storageContextInstance.GetStorageFromAddress(readable, key)
+		data, _, _ = storageCtx.GetStorageFromAddress(readable, key)
 		require.Equal(t, data, internalData)
 
-		data, _, _ = storageContextInstance.GetStorageFromAddress(nonreadable, key)
+		data, _, _ = storageCtx.GetStorageFromAddress(nonreadable, key)
 		require.Nil(t, data)
 	})
 }
@@ -571,10 +566,10 @@ func TestStorageContext_PopSetActiveStateIfStackIsEmptyShouldNotPanic(t *testing
 		EnableEpochsHandlerField: enableEpochsHandler,
 	}
 
-	storageContextInstance, _ := NewStorageContext(host, &contextmock.BlockchainHookStub{}, elrondReservedTestPrefix)
-	storageContextInstance.PopSetActiveState()
+	storageCtx, _ := NewStorageContext(host, &contextmock.BlockchainHookStub{}, elrondReservedTestPrefix)
+	storageCtx.PopSetActiveState()
 
-	require.Equal(t, 0, len(storageContextInstance.stateStack))
+	require.Equal(t, 0, len(storageCtx.stateStack))
 }
 
 func TestStorageContext_PopDiscardIfStackIsEmptyShouldNotPanic(t *testing.T) {
@@ -587,8 +582,8 @@ func TestStorageContext_PopDiscardIfStackIsEmptyShouldNotPanic(t *testing.T) {
 		EnableEpochsHandlerField: enableEpochsHandler,
 	}
 
-	storageContextInstance, _ := NewStorageContext(host, &contextmock.BlockchainHookStub{}, elrondReservedTestPrefix)
-	storageContextInstance.PopDiscard()
+	storageCtx, _ := NewStorageContext(host, &contextmock.BlockchainHookStub{}, elrondReservedTestPrefix)
+	storageCtx.PopDiscard()
 
-	require.Equal(t, 0, len(storageContextInstance.stateStack))
+	require.Equal(t, 0, len(storageCtx.stateStack))
 }
