
#if !defined(WASMER_H_MACROS)

#define WASMER_H_MACROS

// Define the `ARCH_X86_X64` constant.
#if defined(MSVC) && defined(_M_AMD64)
#  define ARCH_X86_64
#elif (defined(GCC) || defined(__GNUC__) || defined(__clang__)) && defined(__x86_64__)
#  define ARCH_X86_64
#endif

// Compatibility with non-Clang compilers.
#if !defined(__has_attribute)
#  define __has_attribute(x) 0
#endif

// Compatibility with non-Clang compilers.
#if !defined(__has_declspec_attribute)
#  define __has_declspec_attribute(x) 0
#endif

// Define the `DEPRECATED` macro.
#if defined(GCC) || defined(__GNUC__) || __has_attribute(deprecated)
#  define DEPRECATED(message) __attribute__((deprecated(message)))
#elif defined(MSVC) || __has_declspec_attribute(deprecated)
#  define DEPRECATED(message) __declspec(deprecated(message))
#endif

#endif // WASMER_H_MACROS


#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * The `wasmer_result_t` enum is a type that represents either a
 * success, or a failure.
 */
typedef enum {
  /**
   * Represents a success.
   */
  VM_EXEC_OK = 1,
  /**
   * Represents a failure.
   */
  VM_EXEC_ERROR = 2,
} vm_exec_result_t;

/**
 * Represents all possibles WebAssembly value types.
 *
 * See `wasmer_value_t` to get a complete example.
 */
enum vm_exec_value_tag {
  /**
   * Represents the `i32` WebAssembly type.
   */
  VM_EXEC_VALUE_I32,
  /**
   * Represents the `i64` WebAssembly type.
   */
  VM_EXEC_VALUE_I64,
};
typedef uint32_t vm_exec_value_tag;

/**
 * Opaque pointer to a `wasmer_runtime::Instance` value in Rust.
 *
 * A `wasmer_runtime::Instance` represents a WebAssembly instance. It
 * is generally generated by the `wasmer_instantiate()` function, or by
 * the `wasmer_module_instantiate()` function for the most common paths.
 */
typedef struct {

} vm_exec_instance_t;

typedef struct {

} vm_exec_import_func_t;

/**
 * Opaque pointer to a `wasmer_runtime::Ctx` value in Rust.
 *
 * An instance context is passed to any host function (aka imported
 * function) as the first argument. It is necessary to read the
 * instance data or the memory, respectively with the
 * `wasmer_instance_context_data_get()` function, and the
 * `wasmer_instance_context_memory()` function.
 *
 * It is also possible to get the instance context outside a host
 * function by using the `wasmer_instance_context_get()`
 * function. See also `wasmer_instance_context_data_set()` to set the
 * instance context data.
 *
 * Example:
 *
 * ```c
 * // A host function that prints data from the WebAssembly memory to
 * // the standard output.
 * void print(wasmer_instance_context_t *context, int32_t pointer, int32_t length) {
 *     // Use `wasmer_instance_context` to get back the first instance memory.
 *     const wasmer_memory_t *memory = wasmer_instance_context_memory(context, 0);
 *
 *     // Continueâ€¦
 * }
 * ```
 */
typedef struct {

} vm_exec_compilation_options_t;

typedef struct {
  const uint8_t *bytes;
  uint32_t bytes_len;
} vm_exec_byte_array;

typedef struct {
  vm_exec_byte_array module_name;
  vm_exec_byte_array import_name;
  const vm_exec_import_func_t *import_func;
} vm_exec_import_t;

vm_exec_result_t vm_check_signatures(vm_exec_instance_t *instance);

int vm_exec_execution_info_flush(char *dest_buffer, int dest_buffer_len);

int vm_exec_execution_info_length(void);

/**
 * Frees memory for the given Func
 */
void vm_exec_import_func_destroy(vm_exec_import_func_t *func);

/**
 * Creates new host function, aka imported function. `func` is a
 * function pointer, where the first argument is the famous `vm::Ctx`
 * (in Rust), or `wasmer_instance_context_t` (in C). All arguments
 * must be typed with compatible WebAssembly native types:
 *
 * | WebAssembly type | C/C++ type |
 * | ---------------- | ---------- |
 * | `i32`            | `int32_t`  |
 * | `i64`            | `int64_t`  |
 * | `f32`            | `float`    |
 * | `f64`            | `double`   |
 *
 * The function pointer must have a lifetime greater than the
 * WebAssembly instance lifetime.
 *
 * The caller owns the object and should call
 * `wasmer_import_func_destroy` to free it.
 */
vm_exec_import_func_t *vm_exec_import_func_new(void (*func)(void *data),
                                               const vm_exec_value_tag *params,
                                               unsigned int params_len,
                                               const vm_exec_value_tag *returns,
                                               unsigned int returns_len);

/**
 * Calls an exported function of a WebAssembly instance by `name`
 * with the provided parameters. The exported function results are
 * stored on the provided `results` pointer.
 *
 * This function returns `vm_exec_result_t::WASMER_OK` upon success,
 * `vm_exec_result_t::WASMER_ERROR` otherwise. You can use
 * `wasmer_last_error_message()` to get the generated error message.
 *
 * Potential errors are the following:
 *
 *   * `instance` is a null pointer,
 *   * `name` is a null pointer,
 *   * `params` is a null pointer.
 *
 * Example of calling an exported function that needs two parameters, and returns one value:
 *
 * ```c
 * // First argument.
 * wasmer_value_t argument_one = {
 *     .tag = WASM_I32,
 *     .value.I32 = 3,
 * };
 *
 * // Second argument.
 * wasmer_value_t argument_two = {
 *     .tag = WASM_I32,
 *     .value.I32 = 4,
 * };
 *
 * // First result.
 * wasmer_value_t result_one;
 *
 * // All arguments and results.
 * wasmer_value_t arguments[] = {argument_one, argument_two};
 * wasmer_value_t results[]   = {result_one};
 *
 * vm_exec_result_t call_result = wasmer_instance_call(
 *     instance,  // instance pointer
 *     "sum",     // the exported function name
 *     arguments, // the arguments
 *     2,         // the number of arguments
 *     results,   // the results
 *     1          // the number of results
 * );
 *
 * if (call_result == WASMER_OK) {
 *     printf("Result is: %d\n", results[0].value.I32);
 * }
 * ```
 */
vm_exec_result_t vm_exec_instance_call(vm_exec_instance_t *instance, const char *func_name_ptr);

/**
 * Frees memory for the given `vm_exec_instance_t`.
 *
 * Check the `wasmer_instantiate()` function to get a complete
 * example.
 *
 * If `instance` is a null pointer, this function does nothing.
 *
 * Example:
 *
 * ```c
 * // Get an instance.
 * vm_exec_instance_t *instance = NULL;
 * wasmer_instantiate(&instance, bytes, bytes_length, imports, 0);
 *
 * // Destroy the instance.
 * wasmer_instance_destroy(instance);
 * ```
 */
void vm_exec_instance_destroy(vm_exec_instance_t *instance);

/**
 * Gets the length in bytes of the last error if any.
 *
 * This can be used to dynamically allocate a buffer with the correct number of
 * bytes needed to store a message.
 */
int vm_exec_last_error_length(void);

/**
 * Gets the last error message if any into the provided buffer
 * `buffer` up to the given `length`.
 *
 * The `length` parameter must be large enough to store the last
 * error message. Ideally, the value should come from
 * `wasmer_last_error_length()`.
 *
 * The function returns the length of the string in bytes, `-1` if an
 * error occurs. Potential errors are:
 *
 *  * The buffer is a null pointer,
 *  * The buffer is too smal to hold the error message.
 *
 * Note: The error message always has a trailing null character.
 * ```
 */
int vm_exec_last_error_message(char *dest_buffer, int dest_buffer_len);

vm_exec_result_t vm_exec_new_instance(vm_exec_instance_t **instance,
                                      uint8_t *wasm_bytes_ptr,
                                      uint32_t wasm_bytes_len,
                                      const vm_exec_compilation_options_t *options_ptr);

vm_exec_result_t vm_exec_set_imports(vm_exec_import_t *imports, unsigned int imports_len);

void vm_exec_set_sigsegv_passthrough(void);

int vm_exported_function_names(vm_exec_instance_t *instance,
                               char *dest_buffer,
                               int dest_buffer_len);

int vm_exported_function_names_length(vm_exec_instance_t *instance);
