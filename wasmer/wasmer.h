
#if !defined(WASMER_H_MACROS)

#define WASMER_H_MACROS

// Define the `ARCH_X86_X64` constant.
#if defined(MSVC) && defined(_M_AMD64)
#  define ARCH_X86_64
#elif (defined(GCC) || defined(__GNUC__) || defined(__clang__)) && defined(__x86_64__)
#  define ARCH_X86_64
#endif

// Compatibility with non-Clang compilers.
#if !defined(__has_attribute)
#  define __has_attribute(x) 0
#endif

// Compatibility with non-Clang compilers.
#if !defined(__has_declspec_attribute)
#  define __has_declspec_attribute(x) 0
#endif

// Define the `DEPRECATED` macro.
#if defined(GCC) || defined(__GNUC__) || __has_attribute(deprecated)
#  define DEPRECATED(message) __attribute__((deprecated(message)))
#elif defined(MSVC) || __has_declspec_attribute(deprecated)
#  define DEPRECATED(message) __declspec(deprecated(message))
#endif

#endif // WASMER_H_MACROS


#ifndef WASMER_H
#define WASMER_H

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#define OPCODE_COUNT 448

/**
 * List of export/import kinds.
 */
enum wasmer_import_export_kind {
  /**
   * The export/import is a function.
   */
  WASM_FUNCTION = 0,
  /**
   * The export/import is a global.
   */
  WASM_GLOBAL = 1,
  /**
   * The export/import is a memory.
   */
  WASM_MEMORY = 2,
  /**
   * The export/import is a table.
   */
  WASM_TABLE = 3,
};
typedef uint32_t wasmer_import_export_kind;

/**
 * The `wasmer_result_t` enum is a type that represents either a
 * success, or a failure.
 */
typedef enum {
  /**
   * Represents a success.
   */
  WASMER_OK = 1,
  /**
   * Represents a failure.
   */
  WASMER_ERROR = 2,
} wasmer_result_t;

/**
 * Represents all possibles WebAssembly value types.
 *
 * See `wasmer_value_t` to get a complete example.
 */
enum wasmer_value_tag {
  /**
   * Represents the `i32` WebAssembly type.
   */
  WASM_I32,
  /**
   * Represents the `i64` WebAssembly type.
   */
  WASM_I64,
  /**
   * Represents the `f32` WebAssembly type.
   */
  WASM_F32,
  /**
   * Represents the `f64` WebAssembly type.
   */
  WASM_F64,
};
typedef uint32_t wasmer_value_tag;

/**
 * Opaque pointer to `wasmer_export_t`.
 */
typedef struct {

} wasmer_export_func_t;

/**
 * Represents a WebAssembly value.
 *
 * This is a [Rust union][rust-union], which is equivalent to the C
 * union. See `wasmer_value_t` to get a complete example.
 *
 * [rust-union]: https://doc.rust-lang.org/reference/items/unions.html
 */
typedef union {
  int32_t I32;
  int64_t I64;
  float F32;
  double F64;
} wasmer_value;

/**
 * Represents a WebAssembly type and value pair,
 * i.e. `wasmer_value_tag` and `wasmer_value`. Since the latter is an
 * union, it's the safe way to read or write a WebAssembly value in
 * C.
 *
 * Example:
 *
 * ```c
 * // Create a WebAssembly value.
 * wasmer_value_t wasm_value = {
 *     .tag = WASM_I32,
 *     .value.I32 = 42,
 * };
 *
 * // Read a WebAssembly value.
 * if (wasm_value.tag == WASM_I32) {
 *     int32_t x = wasm_value.value.I32;
 *     // …
 * }
 * ```
 */
typedef struct {
  /**
   * The value type.
   */
  wasmer_value_tag tag;
  /**
   * The value.
   */
  wasmer_value value;
} wasmer_value_t;

/**
 * Opaque pointer to `NamedExport`.
 */
typedef struct {

} wasmer_export_t;

typedef struct {
  const uint8_t *bytes;
  uint32_t bytes_len;
} wasmer_byte_array;

/**
 * Opaque pointer to a `wasmer_runtime::Memory` value in Rust.
 *
 * A `wasmer_runtime::Memory` represents a WebAssembly memory. It is
 * possible to create one with `wasmer_memory_new()` and pass it as
 * imports of an instance, or to read it from exports of an instance
 * with `wasmer_export_to_memory()`.
 */
typedef struct {

} wasmer_memory_t;

/**
 * Opaque pointer to the opaque structure `crate::NamedExports`,
 * which is a wrapper around a vector of the opaque structure
 * `crate::NamedExport`.
 *
 * Check the `wasmer_instance_exports()` function to learn more.
 */
typedef struct {

} wasmer_exports_t;

typedef struct {

} wasmer_import_func_t;

typedef struct {

} wasmer_table_t;

typedef struct {

} wasmer_global_t;

/**
 * Union of import/export value.
 */
typedef union {
  const wasmer_import_func_t *func;
  const wasmer_table_t *table;
  const wasmer_memory_t *memory;
  const wasmer_global_t *global;
} wasmer_import_export_value;

typedef struct {
  wasmer_byte_array module_name;
  wasmer_byte_array import_name;
  wasmer_import_export_kind tag;
  wasmer_import_export_value value;
} wasmer_import_t;

/**
 * Opaque pointer to a `wasmer_runtime::Instance` value in Rust.
 *
 * A `wasmer_runtime::Instance` represents a WebAssembly instance. It
 * is generally generated by the `wasmer_instantiate()` function, or by
 * the `wasmer_module_instantiate()` function for the most common paths.
 */
typedef struct {

} wasmer_instance_t;

/**
 * Opaque pointer to a `wasmer_runtime::Ctx` value in Rust.
 *
 * An instance context is passed to any host function (aka imported
 * function) as the first argument. It is necessary to read the
 * instance data or the memory, respectively with the
 * `wasmer_instance_context_data_get()` function, and the
 * `wasmer_instance_context_memory()` function.
 *
 * It is also possible to get the instance context outside a host
 * function by using the `wasmer_instance_context_get()`
 * function. See also `wasmer_instance_context_data_set()` to set the
 * instance context data.
 *
 * Example:
 *
 * ```c
 * // A host function that prints data from the WebAssembly memory to
 * // the standard output.
 * void print(wasmer_instance_context_t *context, int32_t pointer, int32_t length) {
 *     // Use `wasmer_instance_context` to get back the first instance memory.
 *     const wasmer_memory_t *memory = wasmer_instance_context_memory(context, 0);
 *
 *     // Continue…
 * }
 * ```
 */
typedef struct {

} wasmer_instance_context_t;

typedef struct {

} wasmer_compilation_options_t;

/**
 * Calls a `func` with the provided parameters.
 * Results are set using the provided `results` pointer.
 *
 * Returns `wasmer_result_t::WASMER_OK` upon success.
 *
 * Returns `wasmer_result_t::WASMER_ERROR` upon failure. Use `wasmer_last_error_length`
 * and `wasmer_last_error_message` to get an error message.
 */
wasmer_result_t wasmer_export_func_call(const wasmer_export_func_t *func,
                                        const wasmer_value_t *params,
                                        unsigned int params_len,
                                        wasmer_value_t *results,
                                        unsigned int results_len);

/**
 * Sets the params buffer to the parameter types of the given wasmer_export_func_t
 *
 * Returns `wasmer_result_t::WASMER_OK` upon success.
 *
 * Returns `wasmer_result_t::WASMER_ERROR` upon failure. Use `wasmer_last_error_length`
 * and `wasmer_last_error_message` to get an error message.
 */
wasmer_result_t wasmer_export_func_params(const wasmer_export_func_t *func,
                                          wasmer_value_tag *params,
                                          uint32_t params_len);

/**
 * Sets the result parameter to the arity of the params of the wasmer_export_func_t
 *
 * Returns `wasmer_result_t::WASMER_OK` upon success.
 *
 * Returns `wasmer_result_t::WASMER_ERROR` upon failure. Use `wasmer_last_error_length`
 * and `wasmer_last_error_message` to get an error message.
 */
wasmer_result_t wasmer_export_func_params_arity(const wasmer_export_func_t *func, uint32_t *result);

/**
 * Sets the returns buffer to the parameter types of the given wasmer_export_func_t
 *
 * Returns `wasmer_result_t::WASMER_OK` upon success.
 *
 * Returns `wasmer_result_t::WASMER_ERROR` upon failure. Use `wasmer_last_error_length`
 * and `wasmer_last_error_message` to get an error message.
 */
wasmer_result_t wasmer_export_func_returns(const wasmer_export_func_t *func,
                                           wasmer_value_tag *returns,
                                           uint32_t returns_len);

/**
 * Sets the result parameter to the arity of the returns of the wasmer_export_func_t
 *
 * Returns `wasmer_result_t::WASMER_OK` upon success.
 *
 * Returns `wasmer_result_t::WASMER_ERROR` upon failure. Use `wasmer_last_error_length`
 * and `wasmer_last_error_message` to get an error message.
 */
wasmer_result_t wasmer_export_func_returns_arity(const wasmer_export_func_t *func,
                                                 uint32_t *result);

/**
 * Gets wasmer_export kind
 */
wasmer_import_export_kind wasmer_export_kind(wasmer_export_t *export_);

/**
 * Gets name from wasmer_export
 */
wasmer_byte_array wasmer_export_name(wasmer_export_t *export_);

/**
 * Gets export func from export
 */
const wasmer_export_func_t *wasmer_export_to_func(const wasmer_export_t *export_);

/**
 * Gets a memory pointer from an export pointer.
 *
 * Returns `wasmer_result_t::WASMER_OK` upon success.
 *
 * Returns `wasmer_result_t::WASMER_ERROR` upon failure. Use `wasmer_last_error_length`
 * and `wasmer_last_error_message` to get an error message.
 */
wasmer_result_t wasmer_export_to_memory(const wasmer_export_t *export_, wasmer_memory_t **memory);

/**
 * Frees the memory for the given exports.
 *
 * Check the `wasmer_instance_exports()` function to get a complete
 * example.
 *
 * If `exports` is a null pointer, this function does nothing.
 *
 * Example:
 *
 * ```c
 * // Get some exports.
 * wasmer_exports_t *exports = NULL;
 * wasmer_instance_exports(instance, &exports);
 *
 * // Destroy the exports.
 * wasmer_exports_destroy(exports);
 * ```
 */
void wasmer_exports_destroy(wasmer_exports_t *exports);

/**
 * Gets wasmer_export by index
 */
wasmer_export_t *wasmer_exports_get(wasmer_exports_t *exports, int idx);

/**
 * Gets the length of the exports
 */
int wasmer_exports_len(wasmer_exports_t *exports);

/**
 * Frees memory for the given Func
 */
void wasmer_import_func_destroy(wasmer_import_func_t *func);

/**
 * Creates new host function, aka imported function. `func` is a
 * function pointer, where the first argument is the famous `vm::Ctx`
 * (in Rust), or `wasmer_instance_context_t` (in C). All arguments
 * must be typed with compatible WebAssembly native types:
 *
 * | WebAssembly type | C/C++ type |
 * | ---------------- | ---------- |
 * | `i32`            | `int32_t`  |
 * | `i64`            | `int64_t`  |
 * | `f32`            | `float`    |
 * | `f64`            | `double`   |
 *
 * The function pointer must have a lifetime greater than the
 * WebAssembly instance lifetime.
 *
 * The caller owns the object and should call
 * `wasmer_import_func_destroy` to free it.
 */
wasmer_import_func_t *wasmer_import_func_new(void (*func)(void *data),
                                             const wasmer_value_tag *params,
                                             unsigned int params_len,
                                             const wasmer_value_tag *returns,
                                             unsigned int returns_len);

wasmer_result_t wasmer_import_object_cache_from_imports(wasmer_import_t *imports,
                                                        unsigned int imports_len);

wasmer_result_t wasmer_instance_cache(wasmer_instance_t *instance,
                                      const uint8_t **cache_bytes,
                                      uint32_t *cache_len);

/**
 * Calls an exported function of a WebAssembly instance by `name`
 * with the provided parameters. The exported function results are
 * stored on the provided `results` pointer.
 *
 * This function returns `wasmer_result_t::WASMER_OK` upon success,
 * `wasmer_result_t::WASMER_ERROR` otherwise. You can use
 * `wasmer_last_error_message()` to get the generated error message.
 *
 * Potential errors are the following:
 *
 *   * `instance` is a null pointer,
 *   * `name` is a null pointer,
 *   * `params` is a null pointer.
 *
 * Example of calling an exported function that needs two parameters, and returns one value:
 *
 * ```c
 * // First argument.
 * wasmer_value_t argument_one = {
 *     .tag = WASM_I32,
 *     .value.I32 = 3,
 * };
 *
 * // Second argument.
 * wasmer_value_t argument_two = {
 *     .tag = WASM_I32,
 *     .value.I32 = 4,
 * };
 *
 * // First result.
 * wasmer_value_t result_one;
 *
 * // All arguments and results.
 * wasmer_value_t arguments[] = {argument_one, argument_two};
 * wasmer_value_t results[]   = {result_one};
 *
 * wasmer_result_t call_result = wasmer_instance_call(
 *     instance,  // instance pointer
 *     "sum",     // the exported function name
 *     arguments, // the arguments
 *     2,         // the number of arguments
 *     results,   // the results
 *     1          // the number of results
 * );
 *
 * if (call_result == WASMER_OK) {
 *     printf("Result is: %d\n", results[0].value.I32);
 * }
 * ```
 */
wasmer_result_t wasmer_instance_call(wasmer_instance_t *instance,
                                     const char *name,
                                     const wasmer_value_t *params,
                                     uint32_t params_len,
                                     wasmer_value_t *results,
                                     uint32_t results_len);

/**
 * Gets the data that can be hold by an instance.
 *
 * This function is complementary of
 * `wasmer_instance_context_data_set()`. Please read its
 * documentation. You can also read the documentation of
 * `wasmer_instance_context_t` to get other examples.
 *
 * This function returns nothing if `ctx` is a null pointer.
 */
void *wasmer_instance_context_data_get(const wasmer_instance_context_t *ctx);

/**
 * Sets the data that can be hold by an instance context.
 *
 * An instance context (represented by the opaque
 * `wasmer_instance_context_t` structure) can hold user-defined
 * data. This function sets the data. This function is complementary
 * of `wasmer_instance_context_data_get()`.
 *
 * This function does nothing if `instance` is a null pointer.
 *
 * Example:
 *
 * ```c
 * // Define your own data.
 * typedef struct {
 *     // …
 * } my_data;
 *
 * // Allocate them and set them on the given instance.
 * my_data *data = malloc(sizeof(my_data));
 * data->… = …;
 * wasmer_instance_context_data_set(instance, (void*) my_data);
 *
 * // You can read your data.
 * {
 *     my_data *data = (my_data*) wasmer_instance_context_data_get(wasmer_instance_context_get(instance));
 *     // …
 * }
 * ```
 */
void wasmer_instance_context_data_set(wasmer_instance_t *instance,
                                      void *data_ptr);

/**
 * Returns the instance context. Learn more by looking at the
 * `wasmer_instance_context_t` struct.
 *
 * This function returns `null` if `instance` is a null pointer.
 *
 * Example:
 *
 * ```c
 * const wasmer_instance_context_get *context = wasmer_instance_context_get(instance);
 * my_data *data = (my_data *) wasmer_instance_context_data_get(context);
 * // Do something with `my_data`.
 * ```
 *
 * It is often useful with `wasmer_instance_context_data_set()`.
 */
const wasmer_instance_context_t *wasmer_instance_context_get(wasmer_instance_t *instance);

/**
 * Gets the `memory_idx`th memory of the instance.
 *
 * Note that the index is always `0` until multiple memories are supported.
 *
 * This function is mostly used inside host functions (aka imported
 * functions) to read the instance memory.
 *
 * Example of a _host function_ that reads and prints a string based on a pointer and a length:
 *
 * ```c
 * void print_string(const wasmer_instance_context_t *context, int32_t pointer, int32_t length) {
 *     // Get the 0th memory.
 *     const wasmer_memory_t *memory = wasmer_instance_context_memory(context, 0);
 *
 *     // Get the memory data as a pointer.
 *     uint8_t *memory_bytes = wasmer_memory_data(memory);
 *
 *     // Print what we assumed to be a string!
 *     printf("%.*s", length, memory_bytes + pointer);
 * }
 * ```
 */
const wasmer_memory_t *wasmer_instance_context_memory(const wasmer_instance_context_t *ctx,
                                                      uint32_t _memory_idx);

/**
 * Frees memory for the given `wasmer_instance_t`.
 *
 * Check the `wasmer_instantiate()` function to get a complete
 * example.
 *
 * If `instance` is a null pointer, this function does nothing.
 *
 * Example:
 *
 * ```c
 * // Get an instance.
 * wasmer_instance_t *instance = NULL;
 * wasmer_instantiate(&instance, bytes, bytes_length, imports, 0);
 *
 * // Destroy the instance.
 * wasmer_instance_destroy(instance);
 * ```
 */
void wasmer_instance_destroy(wasmer_instance_t *instance);

void wasmer_instance_disable_rkyv(void);

void wasmer_instance_enable_rkyv(void);

/**
 * Gets all the exports of the given WebAssembly instance.
 *
 * This function stores a Rust vector of exports into `exports` as an
 * opaque pointer of kind `wasmer_exports_t`.
 *
 * As is, you can do anything with `exports` except using the
 * companion functions, like `wasmer_exports_len()`,
 * `wasmer_exports_get()` or `wasmer_export_kind()`. See the example below.
 *
 * **Warning**: The caller owns the object and should call
 * `wasmer_exports_destroy()` to free it.
 *
 * Example:
 *
 * ```c
 * // Get the exports.
 * wasmer_exports_t *exports = NULL;
 * wasmer_instance_exports(instance, &exports);
 *
 * // Get the number of exports.
 * int exports_length = wasmer_exports_len(exports);
 * printf("Number of exports: %d\n", exports_length);
 *
 * // Read the first export.
 * wasmer_export_t *export = wasmer_exports_get(exports, 0);
 *
 * // Get the kind of the export.
 * wasmer_import_export_kind export_kind = wasmer_export_kind(export);
 *
 * // Assert it is a function (why not).
 * assert(export_kind == WASM_FUNCTION);
 *
 * // Read the export name.
 * wasmer_byte_array name_bytes = wasmer_export_name(export);
 *
 * assert(name_bytes.bytes_len == sizeof("sum") - 1);
 * assert(memcmp(name_bytes.bytes, "sum", sizeof("sum") - 1) == 0);
 *
 * // Destroy the exports.
 * wasmer_exports_destroy(exports);
 * ```
 */
void wasmer_instance_exports(wasmer_instance_t *instance, wasmer_exports_t **exports);

wasmer_result_t wasmer_instance_from_cache(wasmer_instance_t **instance,
                                           uint8_t *cache_bytes,
                                           uint32_t cache_len,
                                           const wasmer_compilation_options_t *options);

uint64_t wasmer_instance_get_points_used(wasmer_instance_t *instance);

uint64_t wasmer_instance_get_runtime_breakpoint_value(wasmer_instance_t *instance);

/**
 * Verifies whether the specified function name is imported by the given instance.
 */
bool wasmer_instance_is_function_imported(wasmer_instance_t *instance, const char *name);

/**
 * Reset an WebAssembly instance, cleaning memories and globals
 */
wasmer_result_t wasmer_instance_reset(wasmer_instance_t *instance);

void wasmer_instance_set_points_limit(wasmer_instance_t *instance, uint64_t limit);

void wasmer_instance_set_points_used(wasmer_instance_t *instance, uint64_t new_gas);

void wasmer_instance_set_runtime_breakpoint_value(wasmer_instance_t *instance, uint64_t value);

wasmer_result_t wasmer_instantiate_with_options(wasmer_instance_t **instance,
                                                uint8_t *wasm_bytes,
                                                uint32_t wasm_bytes_len,
                                                const wasmer_compilation_options_t *options);

/**
 * Gets the length in bytes of the last error if any.
 *
 * This can be used to dynamically allocate a buffer with the correct number of
 * bytes needed to store a message.
 *
 * See `wasmer_last_error_message()` to get a full example.
 */
int wasmer_last_error_length(void);

/**
 * Gets the last error message if any into the provided buffer
 * `buffer` up to the given `length`.
 *
 * The `length` parameter must be large enough to store the last
 * error message. Ideally, the value should come from
 * `wasmer_last_error_length()`.
 *
 * The function returns the length of the string in bytes, `-1` if an
 * error occurs. Potential errors are:
 *
 *  * The buffer is a null pointer,
 *  * The buffer is too smal to hold the error message.
 *
 * Note: The error message always has a trailing null character.
 *
 * Example:
 *
 * ```c
 * int error_length = wasmer_last_error_length();
 *
 * if (error_length > 0) {
 *     char *error_message = malloc(error_length);
 *     wasmer_last_error_message(error_message, error_length);
 *     printf("Error message: `%s`\n", error_message);
 * } else {
 *     printf("No error message\n");
 * }
 * ```
 */
int wasmer_last_error_message(char *buffer, int length);

/**
 * Gets a pointer to the beginning of the contiguous memory data
 * bytes.
 *
 * The function returns `NULL` if `memory` is a null pointer.
 *
 * Note that when the memory grows, it can be reallocated, and thus
 * the returned pointer can be invalidated.
 *
 * Example:
 *
 * ```c
 * uint8_t *memory_data = wasmer_memory_data(memory);
 * char *str = (char*) malloc(sizeof(char) * 7);
 *
 * for (uint32_t nth = 0; nth < 7; ++nth) {
 *     str[nth] = (char) memory_data[nth];
 * }
 * ```
 */
uint8_t *wasmer_memory_data(const wasmer_memory_t *memory);

/**
 * Gets the size in bytes of the memory data.
 *
 * This function returns 0 if `memory` is a null pointer.
 *
 * Example:
 *
 * ```c
 * uint32_t memory_data_length = wasmer_memory_data_length(memory);
 * ```
 */
uint32_t wasmer_memory_data_length(wasmer_memory_t *memory);

/**
 * Frees memory for the given `wasmer_memory_t`.
 *
 * Check the `wasmer_memory_new()` function to get a complete
 * example.
 *
 * If `memory` is a null pointer, this function does nothing.
 *
 * Example:
 *
 * ```c
 * // Get a memory.
 * wasmer_memory_t *memory = NULL;
 * wasmer_result_t result = wasmer_memory_new(&memory, memory_descriptor);
 *
 * // Destroy the memory.
 * wasmer_memory_destroy(memory);
 * ```
 */
void wasmer_memory_destroy(wasmer_memory_t *memory);

/**
 * Grows a memory by the given number of pages (of 65Kb each).
 *
 * The functions return `wasmer_result_t::WASMER_OK` upon success,
 * `wasmer_result_t::WASMER_ERROR` otherwise. Use
 * `wasmer_last_error_length()` with `wasmer_last_error_message()` to
 * read the error message.
 *
 * Example:
 *
 * ```c
 * wasmer_result_t result = wasmer_memory_grow(memory, 10);
 *
 * if (result != WASMER_OK) {
 *     // …
 * }
 * ```
 */
wasmer_result_t wasmer_memory_grow(wasmer_memory_t *memory, uint32_t delta);

/**
 * Reads the current length (in pages) of the given memory.
 *
 * The function returns zero if `memory` is a null pointer.
 *
 * Example:
 *
 * ```c
 * uint32_t memory_length = wasmer_memory_length(memory);
 *
 * printf("Memory pages length: %d\n", memory_length);
 * ```
 */
uint32_t wasmer_memory_length(const wasmer_memory_t *memory);

void wasmer_set_opcode_costs(const uint32_t *opcode_costs_pointer);

void wasmer_set_sigsegv_passthrough(void);

#endif /* WASMER_H */
